import java.util.HashMap
import java.util.concurrent.locks.ReentrantLock
import org.openhab.core.model.script.ScriptServiceUtil


//constants
val String REASON_HEALTH_SAFETY = "health_safety"
val String REASON_MANUAL        = "manual"
val String REASON_TIME          = "time"
val String REASON_MOTION        = "motion"
val String REASON_WEATHER       = "weather"
val String REASON_TIMER         = "timer"
val String REASON_OTHER         = "other"
val String REASON_GOODNIGHT     = "goodnight"

/** Livingroom Scenes */
val String SCENE_MORNING   = "morning"
val String SCENE_NORMAL    = "normal"
val String SCENE_HALFNORMAL= "halfnormal"
val String SCENE_TV        = "tv"
val String SCENE_MOVIE     = "movie"
val String SCENE_COZY      = "cozy"
val String SCENE_DARK      = "dark"

/** Livingroom Moods */
val String MOOD_MORNING        = "morning"
val String MOOD_AFTERNOON      = "afternoon"
val String MOOD_EARLY_EVENING  = "early_evening"
val String MOOD_MID_EVENING    = "mid_evening"
val String MOOD_LATE_EVENING   = "late_evening"
val String MOOD_BEDTIME        = "bedtime"
val String MOOD_COZY           = "cozy"
val String MOOD_CHIPPER        = "chipper"
val String MOOD_FESTIVE_XMAS   = "xmas"
val String MOOD_FESTIVE_STP    = "stpatricks"
val String MOOD_FESTIVE_JULY4  = "july4"
val String MOOD_FESTIVE_EASTER = "easter"
val String MOOD_FESTIVE_HALOWN = "halloween"
val String MOOD_EMERGENCY      = "emergency"


/** Kitchen Scenes */
val String SCENE_K_EARLY_MORNING = "earlymorning"
val String SCENE_K_LATE_MORNING  = "latemorning"
val String SCENE_K_AFTERNOON     = "afternoon"
val String SCENE_K_COOKING       = "cooking"
val String SCENE_K_DINNER        = "dinner"
val String SCENE_K_EVENING       = "evening"
val String SCENE_K_DARK          = "dark"


val HashMap<String, String>   lastStateReason = newHashMap()
val HashMap<String, ZonedDateTime> lastStateDate   = newHashMap()
val HashMap<String, Timer>    autoOffTimers   = newHashMap()

val java.util.Random rand = new java.util.Random

//val ReentrantLock automationLock = null //new ReentrantLock()


val isOKToTurnOnBecause = [ GenericItem item, String reason, HashMap<String, String> itemReason, HashMap<String, ZonedDateTime> itemTime | 

    var String oldReason = itemReason.get(item.name);
    if (null === oldReason) { oldReason = ""; }

    var currentState = item.state;
    
    //90 minutes seems like a good wait time for manual overrides. we'll see how it goes
    //this will probably come from group membership or something
    var ZonedDateTime oldTime;
    try {
        oldTime = itemTime.get(item.name);
        if (null === oldTime) { oldTime = now; }
    } catch (Throwable t) {
        logWarn("isOKToTurnOn", "Failed getting a time:" + t.getMessage())
        oldTime = now.minusMinutes(100)
    }

    var boolean manualTimeExpired = true;
    var boolean goodnightTimeExpired = true;

    try{
        manualTimeExpired    = now.minusMinutes(90).isAfter(oldTime);
        goodnightTimeExpired = now.getDayOfMonth() != oldTime.getDayOfMonth(); 
    }
    catch (Throwable t) {
        logWarn("isOKToTurnOn", "Failed doing time comparisons:" + t.getMessage())
        manualTimeExpired = true
        goodnightTimeExpired = true
    }

    var boolean retval = true;


    if (reason != "health_safety" && oldReason == "health_safety") {
        logDebug("isOkToTurnOnBecause", item.name + "update denied because it's not health_safety");
        retval = false;
    }
    else if (oldReason == "manual" && ! manualTimeExpired) {
        logDebug("isOkToTurnOnBecause", item.name + "update denied because current state was set manually");
        retval = false;
    }
    //don't "downgrade" a reason for something to already be on
    else if ( (currentState != OFF && currentState != 0) && (
        (reason == "weather" && (oldReason == "time")) ||
        (reason == "other"   && (oldReason == "time" || oldReason == "weather")) ||
        (reason == "timer"   && (oldReason == "time" || oldReason == "weather" || oldReason == "other")) ||
        (reason == "motion"  && (oldReason == "time" || oldReason == "weather" || oldReason == "other" || oldReason == "timer"))
        ))
    {
        logDebug("isOkToTurnOnBecause", item.name + "update denied because it's a downgrade of current reason: " + oldReason + " to " + reason);
        retval = false;
    }
    else if ("timer" == reason && oldReason =="goodnight") {
        logDebug("isOkToTurnOnBecause", item.name + "update denied because timers can't overrule goodnight");
        retval = false;
    }
    //time can only overrule goodnight if we've crossed midnight
    else if ("time" == reason && "goodnight" == oldReason && ! goodnightTimeExpired) {
        logDebug("isOkToTurnOnBecause",  item.name + "update denied because time can't overrule goodnight on the same day");
        retval = false;
    }

    if (retval == true) {
        //logDebug("isOkToTurnOnBecause", item.name + "allowing update");
    }

    retval
]

val isOKToTurnOffBecause = [ GenericItem item, String reason, HashMap<String, String> itemReason, HashMap<String, ZonedDateTime> itemTime | 

    var String oldReason = itemReason.get(item.name);
    if (null == oldReason) { oldReason = ""; }

    var currentState = item.state;
    
    //90 minutes seems like a good wait time for manual overrides. we'll see how it goes
    //this will probably come from group membership or something
    var ZonedDateTime oldTime
    try {
        oldTime = itemTime.get(item.name);
        if (null == oldTime) { oldTime = now; }
    } catch (Throwable t) {
        logWarn("isOKToTurnOFF", "Failed getting a time:" + t.getMessage())
        oldTime = now.minusMinutes(100);
    }

    var boolean manualTimeExpired = true
    var boolean goodnightTimeExpired = true

    try{
        manualTimeExpired    = now.minusMinutes(90).isAfter(oldTime);
        goodnightTimeExpired = now.getDayOfMonth() != oldTime.getDayOfMonth(); 
    }
    catch (Throwable t) {
        logWarn("isOKToTurnOFF", "Failed doing time comparisons:" + t.getMessage())
        manualTimeExpired = true
        goodnightTimeExpired = true
    }

    var boolean retval = true;

    if (reason != "health_safety" && oldReason == "health_safety") {
        logDebug("isOkToTurnOffBecause", item.name + "update denied because it's not health_safety");
        retval = false;
    }
    else if (reason=="goodnight"){
        logDebug("isOkToTurnOffBecause", item.name + "update APPROVED because goodnight");
        retval = true; //goodnight is a wierd quaisi manual reason that can override basically anything
    }
    //timers can overide manual (otherwise auto-off timers wouldn't work)
    else if (oldReason == "manual" && ! manualTimeExpired && "timer" != reason) {
        logWarn("isOkToTurnOffBecause", item.name + "update denied because state was set manually and manual time has not expired");
        retval = false;
    }
    //don't downgrade a reason for something to be off
    else if (!(currentState != OFF && currentState != 0) && (
        (reason == "weather" && (oldReason == "time")) ||
        (reason == "other" &&   (oldReason == "time" || oldReason == "weather")) ||
        (reason == "timer" &&   (oldReason == "time" || oldReason == "weather" || oldReason == "other")) ||
        (reason == "motion" &&  (oldReason == "time" || oldReason == "weather" || oldReason == "other" || oldReason == "timer"))
    ))
    {
        logDebug("isOkToTurnOffBecause", item.name + "update denied because it's a downgrade of current reason: " + oldReason + " to " + reason);
        retval = false;
    }

    retval
]


//used as a flag to the global item update handler
//that an ongoing automatic operation is running, 
//to distinguish from an update caused by a person
//pushing a button/switch or giving Alexa a command
var int isUpdateAutomatic = 0


rule "Luminance and Sun control vIsLightOut"
when
    Item FrontPorchMultisensor_SensorLuminance changed or
    Item LocalSun_Position_Elevation changed
then
    var Number luminance
    var Number elevation
    var Number time = (now.getHour() * 100) + now.getMinute()
    
    try {
        luminance = (FrontPorchMultisensor_SensorLuminance.state as Number).intValue
    }
    catch (Throwable t) {
        luminance = null
        logWarn("vIsLightOut", "failed to compute luminance from " + FrontPorchMultisensor_SensorLuminance.state)
    }

    try{
        elevation = (LocalSun_Position_Elevation.state as Number).intValue
    }
    catch(Throwable t){
        elevation = null
        logWarn("vIsLightOut", "failed to compute elevation from " + LocalSun_Position_Elevation.state)
    }

    if ((luminance < 10 || elevation < 1) && vIsLightOut.state == ON) {
        vIsLightOut.postUpdate(OFF)
    }
    else if ((luminance > 20 && elevation > 1) && vIsLightOut.state == OFF && (time >= 730)) {
        vIsLightOut.postUpdate(ON)
    }
end






rule "Choose new kitchen accent every day"
when
    Time cron "0 0 0 ? * *"
then
    //Choose a random color for the kitchen mood
    vKitchenMoodColor.postUpdate(new HSBType(new DecimalType(rand.nextInt(360)), new PercentType(30 + rand.nextInt(50)), new PercentType(100)));
end


rule "Kitchen Scene Manager"
when
  System started or
  Time cron "0 0 5  ? * * " or
  Time cron "0 0 9  ? * * " or
  Time cron "0 0 12 ? * * " or
  Time cron "0 0 17 ? * * " or
  Time cron "0 0 19 ? * * " or
  Item KitchenMultisensor_SensorLuminance received update
then
    var Number hour = now.getHour();
    var Number day  = now.getDayOfWeek().getValue();
    var Number luminance = KitchenMultisensor_SensorLuminance.state as Number;


    var String oldScene = vKitchenScene.state.toString();
    var String newScene = SCENE_K_DARK;


    if (hour >= 19 && oldScene != SCENE_K_DARK) {
        newScene = SCENE_K_EVENING;
    }
    else if (hour >= 16) {
        newScene = SCENE_K_COOKING;
    }
    else if (hour >= 12) {
        newScene = SCENE_K_AFTERNOON;
    }
    else if (hour >= 9) {
        newScene = SCENE_K_LATE_MORNING;
    }
    else if (hour >= 5) {
        newScene = SCENE_K_EARLY_MORNING;
    }

    //automationLock.lock()
    try {
        isUpdateAutomatic += 1;

        if (isOKToTurnOnBecause.apply(vKitchenScene, REASON_TIME, lastStateReason, lastStateDate)){
            vKitchenScene.postUpdate(newScene);
            lastStateReason.put(vKitchenScene.name, REASON_TIME);
            lastStateDate.put(vKitchenScene.name, now);
        }
    }
    catch (Throwable t) {
        logError("Kitchen Scene Manager", t.getMessage())
    }
    finally {
        createTimer(now.plusSeconds(1), [ | isUpdateAutomatic -= 1; ]);
        //automationLock.unlock()
    }
end


rule "Kitchen Scene Applier"
when
    Item vKitchenScene changed or
    Item vKitchenMoodColor changed or
    Time cron "0 */15 * ? * *"
then
    var sinkLights = OFF;
    var coffeeColor = new HSBType(new DecimalType(0), new PercentType(0), new PercentType(0));
    var coffeeLights = 0;
    var counterColor = new HSBType(new DecimalType(0), new PercentType(0), new PercentType(0));
    var counterLights = 0;
    var coffeeTemp = 0;
    var barLights = 0;
    var diningroomLights = 0;
    var chinaLights = 0;

    logInfo("kitchen_scene_applier", "starting setup of kitchen scene: " + vKitchenScene.state.toString());

    if (null === vKitchenMoodColor.state) {
        vKitchenMoodColor.postUpdate(new HSBType(new DecimalType(rand.nextInt(360)), new PercentType(30 + rand.nextInt(50)), new PercentType(100)));
        Thread::sleep(10);
    }

    createTimer(now.plusSeconds(1), [ | isUpdateAutomatic -= 1; ]);
    isUpdateAutomatic += 1;


    switch(vKitchenScene.state.toString()){
        case SCENE_K_EARLY_MORNING: {
            coffeeLights     = 100;
            coffeeTemp       = 100;
            counterColor     = vKitchenMoodColor.state as HSBType;
            }
        case SCENE_K_LATE_MORNING: {
            coffeeLights     = 100;
            coffeeTemp       = 50;
            counterColor     = vKitchenMoodColor.state as HSBType;
            }
        case SCENE_K_AFTERNOON: {
            coffeeColor      = vKitchenMoodColor.state as HSBType;
            counterColor     = vKitchenMoodColor.state as HSBType;
            barLights        = 100;
            chinaLights      = 50;
            }
        case SCENE_K_COOKING: {
            sinkLights       = ON;
            coffeeLights     = 100;
            counterLights    = 100;
            coffeeTemp       = 100;
            barLights        = 100;
            diningroomLights = 50;
            chinaLights      = 100;
            }
        case SCENE_K_DINNER: {
            coffeeColor      = vKitchenMoodColor.state as HSBType;
            counterColor     = vKitchenMoodColor.state as HSBType;
            barLights        = 100;
            diningroomLights = 100;
            chinaLights      = 100;
            }
        case SCENE_K_EVENING: {
            sinkLights       = ON;
            coffeeColor      = vKitchenMoodColor.state as HSBType;
            counterColor     = vKitchenMoodColor.state as HSBType;
            barLights        = 100;
            diningroomLights = 50;
            chinaLights      = 100;
            }
    }

    try {
        logWarn("kitchen_scene_applier", "setting coffee dimmer / color: " + coffeeLights + " " + coffeeColor);
        CoffeeLight_Temperature2.sendCommand(coffeeTemp);
        CoffeeLight_Dimmer.sendCommand(coffeeLights);

        CoffeeLight_Color.sendCommand(if (coffeeColor.getBrightness() > 0) coffeeColor else OFF );
    } catch (Throwable t) {logError("kitchen_scene_applier", "failed to set coffee dimmer/color: " + t.getMessage());}

    try {
        logWarn("kitchen_scene_applier", "setting counter dimmer / color: " + counterLights + " " + counterColor);
        CounterLight_Temperature.sendCommand(coffeeTemp);
        CounterLight_Dimmer.sendCommand(counterLights);

        CounterLight_Color.sendCommand(if (counterColor.getBrightness() > 0) counterColor else OFF);
    } catch (Throwable t) {logError("kitchen_scene_applier", "failed to set counter dimmer/color: " + t.getMessage());}


    logInfo("kitchen_scene_applier", "finishsed setting up kitchen scene");
end


///
/// Variously-triggered blinds rules
///

rule "Non-Bedroom blinds open in the morning"
when
    Time cron "0 30 8 ? * MON-FRI" or
    Time cron "0  0 9 ? * SAT,SUN" or
    Item vIsLightOut changed from OFF to ON
then
    var String ourreason = REASON_TIME;

    if (triggeringItemName !== null && triggeringItemName == "vIsLightOut") {
        ourreason = REASON_WEATHER;
    }

    //automationLock.lock()
    try {
        isUpdateAutomatic += 1;

        gAllBlinds.members.filter[ b | !b.getGroupNames.contains("gBedroomBlinds") ].forEach [ b | 
            if (isOKToTurnOnBecause.apply(b, ourreason, lastStateReason, lastStateDate)) {
                b.sendCommand(UP)
                lastStateReason.put(b.name, ourreason);
                lastStateDate.put(b.name, now);
            }
        ]
    }
    catch (Throwable t) {
        logError("non-bedroom blinds", t.getMessage())
    }
    finally {
        createTimer(now.plusSeconds(1), [ | isUpdateAutomatic -= 1; ]);
        //automationLock.unlock()
    }
end


rule "Bedroom blinds open in the morning"
when
    Time cron "0 45 8 ? * MON-FRI" or
    Time cron "0 15 9 ? * SAT,SUN"
then
    logDebug("bedroom blinds", "rule triggered")

    //automationLock.lock()
    try {
        isUpdateAutomatic += 1;

        gBedroomBlinds.members.forEach [ b | 
            if (isOKToTurnOnBecause.apply(b, REASON_TIME, lastStateReason, lastStateDate)) {
                b.sendCommand(UP)
                lastStateReason.put(b.name, REASON_TIME);
                lastStateDate.put(b.name, now);
            }
        ]
    }
    catch (Throwable t) {
        logError("bedroom blinds", t.getMessage())
    }
    finally {
        createTimer(now.plusSeconds(1), [ | isUpdateAutomatic -= 1; ]);
        //automationLock.unlock()
    }
end

rule "Upstairs Blinds Close when the sun comes around"
when
  Item LocalSun_Position_Azimuth changed   
then
  var int cloudiness =(LocalWeatherAndForecast_Current_Cloudiness.state as Number).intValue
  var int sunpos = (LocalSun_Position_Azimuth.state as Number).intValue
  var int sunelv = (LocalSun_Position_Elevation.state as Number).intValue

  if (sunpos > 122 && sunpos < 130 && cloudiness < 50 && sunelv > 40) {
    isUpdateAutomatic += 1;
    createTimer(now.plusSeconds(1), [ | isUpdateAutomatic -= 1; ]);
    logInfo("upstairs-blinds-sun-close.rule", "closing upstairs blinds to prevent the sun from coming in")
    if (isOKToTurnOffBecause.apply(RyansOfficeBlinds_Rollershutter, REASON_WEATHER, lastStateReason, lastStateDate)) {
        RyansOfficeBlinds_Rollershutter.sendCommand(DOWN);
        lastStateReason.put(RyansOfficeBlinds_Rollershutter.name, REASON_WEATHER);
        lastStateDate.put(RyansOfficeBlinds_Rollershutter.name, now);
    }
    if (isOKToTurnOffBecause.apply(StairwellBlinds_Rollershutter, REASON_WEATHER, lastStateReason, lastStateDate)) {
        StairwellBlinds_Rollershutter.sendCommand(DOWN);
        lastStateReason.put(StairwellBlinds_Rollershutter.name, REASON_WEATHER);
        lastStateDate.put(StairwellBlinds_Rollershutter.name, now);
    }
  }

  if (sunpos > 214 && sunpos < 220 && sunelv > 40) {
    isUpdateAutomatic += 1;
    createTimer(now.plusSeconds(1), [ | isUpdateAutomatic -= 1; ]);
    if (isOKToTurnOnBecause.apply(RyansOfficeBlinds_Rollershutter, REASON_WEATHER, lastStateReason, lastStateDate)) {
        RyansOfficeBlinds_Rollershutter.sendCommand(UP);
        lastStateReason.put(RyansOfficeBlinds_Rollershutter.name, REASON_WEATHER);
        lastStateDate.put(RyansOfficeBlinds_Rollershutter.name, now);
    }
    if (isOKToTurnOnBecause.apply(StairwellBlinds_Rollershutter, REASON_WEATHER, lastStateReason, lastStateDate)) {
        StairwellBlinds_Rollershutter.sendCommand(UP);
        lastStateReason.put(StairwellBlinds_Rollershutter.name, REASON_WEATHER);
        lastStateDate.put(StairwellBlinds_Rollershutter.name, now);
    }
  }
end

rule "All blinds close when it gets dark out"
when
    Item vIsLightOut changed from ON to OFF or
    Channel "astro:sun:local:set#event" triggered START or
    Time cron "0 45 20 * * ?"
then
    var ourreason = REASON_TIME;
    if (triggeringItemName !== null && triggeringItemName == "vIsLightOut") {
        ourreason = REASON_WEATHER;
    }

    //automationLock.lock()
    try {
        isUpdateAutomatic += 1;

        gAllBlinds.members.forEach [ blind | 
	    logInfo("blinds_close", blind.name);
            if (isOKToTurnOffBecause.apply(blind, ourreason, lastStateReason, lastStateDate)) {
                blind.sendCommand(DOWN)
                lastStateReason.put(blind.name, ourreason);
                lastStateDate.put(blind.name, now);
            }
	    else {
		logError("blinds_close", "denied for " + blind.name);
	    }
        ]
    }
    catch (Throwable t) {
        logError("blinds close", t.getMessage())
    }
    finally {
        createTimer(now.plusSeconds(1), [ | isUpdateAutomatic -= 1; ]);
        //automationLock.unlock();
    }
end

///
/// Weather based rules
///

rule "Auto Deck Lights"
when
  Item LocalSun_Position_Elevation changed
then
  var int cloudiness =(LocalWeatherAndForecast_Current_Cloudiness.state as Number).intValue
  var int temperature = (LocalWeatherAndForecast_Current_OutdoorTemperature.state as Number).intValue
  var int elevation = (LocalSun_Position_Elevation.state as Number).intValue

  //the cloudier it is, the earlier the lights should turn on
  var int topElevation = 15 + ( 20 * (cloudiness / 100))

  //68 is a rough guess of when we'd likely be outside
  if (elevation < topElevation && elevation > 0 && temperature > 68) {
      //automationLock.lock()
      try{
        isUpdateAutomatic += 1;
        if (isOKToTurnOnBecause.apply(DeckLights_Switch, REASON_WEATHER, lastStateReason, lastStateDate)){
            DeckLights_Switch.sendCommand(ON);
            lastStateReason.put(DeckLights_Switch.name, REASON_WEATHER);
            lastStateDate.put(DeckLights_Switch.name, now);
        }

        if (isOKToTurnOnBecause.apply(PorchLights_Switch, REASON_WEATHER, lastStateReason, lastStateDate)){
            PorchLights_Switch.sendCommand(ON);
            lastStateReason.put(PorchLights_Switch.name, REASON_WEATHER);
            lastStateDate.put(PorchLights_Switch.name, now);
        }
      }
      catch (Throwable t) {
        logError("deck lights", t.getMessage())
      }
      finally {
        createTimer(now.plusSeconds(1), [ | isUpdateAutomatic -= 1; ]);
        //automationLock.unlock()
      }
  }
end


