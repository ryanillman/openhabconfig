import java.util.HashMap
import java.util.concurrent.locks.ReentrantLock
import org.eclipse.smarthome.model.script.ScriptServiceUtil


//constants
val String REASON_HEALTH_SAFETY = "health_safety"
val String REASON_MANUAL        = "manual"
val String REASON_TIME          = "time"
val String REASON_MOTION        = "motion"
val String REASON_WEATHER       = "weather"
val String REASON_TIMER         = "timer"
val String REASON_OTHER         = "other"
val String REASON_GOODNIGHT     = "goodnight"


val String SCENE_MORNING   = "morning"
val String SCENE_NORMAL    = "normal"
val String SCENE_TV        = "tv"
val String SCENE_MOVIE     = "movie"
val String SCENE_COZY      = "cozy"
val String SCENE_DARK      = "dark"


val String MOOD_MORNING        = "morning"
val String MOOD_AFTERNOON      = "afternoon"
val String MOOD_EARLY_EVENING  = "early_evening"
val String MOOD_MID_EVENING    = "mid_evening"
val String MOOD_LATE_EVENING   = "late_evening"
val String MOOD_BEDTIME        = "bedtime"
val String MOOD_COZY           = "cozy"
val String MOOD_CHIPPER        = "chipper"
val String MOOD_FESTIVE_XMAS   = "xmas"
val String MOOD_FESTIVE_STP    = "stpatricks"
val String MOOD_FESTIVE_JULY4  = "july4"
val String MOOD_FESTIVE_EASTER = "easter"

val HashMap<String, String>   lastStateReason = newHashMap()
val HashMap<String, DateTime> lastStateDate   = newHashMap()
val HashMap<String, Timer>    autoOffTimers   = newHashMap()

val ReentrantLock automationLock = null //new ReentrantLock()


val org.eclipse.xtext.xbase.lib.Functions$Function4 <GenericItem, String, HashMap<String, String>, HashMap<String, DateTime>, Boolean> isOKToTurnOnBecause = [ 
    GenericItem item, String reason, HashMap<String, String> itemReason, HashMap<String, DateTime> itemTime | 

    var String oldReason = itemReason.get(item.name);
    if (oldReason === null) { oldReason = ""; }

    var currentState = item.state;
    
    //90 minutes seems like a good wait time for manual overrides. we'll see how it goes
    //this will probably come from group membership or something
    var DateTime oldTime
    try {
        itemTime.get(item.name);
        if (oldTime === null) { oldTime = now; }
    } catch (Throwable t) {
        logWarn("isOKToTurnOn", "Failed getting a time:" + t.getMessage())
        oldTime = now
    }

    var boolean manualTimeExpired = false
    var boolean goodnightTimeExpired = false

    try{
        manualTimeExpired    = now.minusMinutes(90).isAfter(oldTime);
        goodnightTimeExpired = now.getDayOfMonth() != oldTime.getDayOfMonth(); 
    }
    catch (Throwable t) {
        logWarn("isOKToTurnOn", "Failed doing time comparisons:" + t.getMessage())
        manualTimeExpired = true
        goodnightTimeExpired = true
    }

    var boolean retval = true;


    if (reason != "health_safety" && oldReason == "health_safety") {
        logDebug("isOkToTurnOnBecause", item.name + "update denied because it's not health_safety");
        retval = false;
    }
    else if (oldReason == "manual" && ! manualTimeExpired) {
        logDebug("isOkToTurnOnBecause", item.name + "update denied because current state was set manually");
        retval = false;
    }
    //don't "downgrade" a reason for something to already be on
    else if ( (currentState != OFF && currentState != 0) && (
        (reason == "weather" && (oldReason == "time")) ||
        (reason == "other"   && (oldReason == "time" || oldReason == "weather")) ||
        (reason == "timer"   && (oldReason == "time" || oldReason == "weather" || oldReason == "other")) ||
        (reason == "motion"  && (oldReason == "time" || oldReason == "weather" || oldReason == "other" || oldReason == "timer"))
        ))
    {
        logDebug("isOkToTurnOnBecause", item.name + "update denied because it's a downgrade of current reason: " + oldReason + " to " + reason);
        retval = false;
    }
    else if ("timer" == reason && oldReason =="goodnight") {
        logDebug("isOkToTurnOnBecause", item.name + "update denied because timers can't overrule goodnight");
        retval = false;
    }
    //time can only overrule goodnight if we've crossed midnight
    else if ("time" == reason && "goodnight" == oldReason && ! goodnightTimeExpired) {
        logDebug("isOkToTurnOnBecause",  item.name + "update denied because time can't overrule goodnight on the same day");
        retval = false;
    }

    if (retval == true) {
        //logDebug("isOkToTurnOnBecause", item.name + "allowing update");
    }

    retval
]

val org.eclipse.xtext.xbase.lib.Functions$Function4<GenericItem, String, HashMap<String, String>, HashMap<String, DateTime>, Boolean> isOKToTurnOffBecause = [ 
    GenericItem item, String reason, HashMap<String, String> itemReason, HashMap<String, DateTime> itemTime | 

    var String oldReason = itemReason.get(item.name);
    if (oldReason === null) { oldReason = ""; }

    var currentState = item.state;
    
    //90 minutes seems like a good wait time for manual overrides. we'll see how it goes
    //this will probably come from group membership or something
    var DateTime oldTime
    try {
        itemTime.get(item.name);
        if (oldTime === null) { oldTime = now; }
    } catch (Throwable t) {
        logWarn("isOKToTurnOFF", "Failed getting a time:" + t.getMessage())
        oldTime = now
    }

    var boolean manualTimeExpired = false
    var boolean goodnightTimeExpired = false

    try{
        manualTimeExpired    = now.minusMinutes(90).isAfter(oldTime);
        goodnightTimeExpired = now.getDayOfMonth() != oldTime.getDayOfMonth(); 
    }
    catch (Throwable t) {
        logWarn("isOKToTurnOFF", "Failed doing time comparisons:" + t.getMessage())
        manualTimeExpired = true
        goodnightTimeExpired = true
    }

    var boolean retval = true;

    if (reason != "health_safety" && oldReason == "health_safety") {
        logDebug("isOkToTurnOffBecause", item.name + "update denied because it's not health_safety");
        retval = false;
    }
    else if (reason=="goodnight"){
        logDebug("isOkToTurnOffBecause", item.name + "update APPROVED because goodnight");
        retval = true; //goodnight is a wierd quaisi manual reason that can override basically anything
    }
    //timers can overide manual (otherwise auto-off timers wouldn't work)
    else if (oldReason == "manual" && ! manualTimeExpired && "timer" != reason) {
        logDebug("isOkToTurnOffBecause", item.name + "update denied because state was set manually and manual time has not expired");
        retval = false;
    }
    //don't downgrade a reason for something to be off
    else if (!(currentState != OFF && currentState != 0) && (
        (reason == "weather" && (oldReason == "time")) ||
        (reason == "other" &&   (oldReason == "time" || oldReason == "weather")) ||
        (reason == "timer" &&   (oldReason == "time" || oldReason == "weather" || oldReason == "other")) ||
        (reason == "motion" &&  (oldReason == "time" || oldReason == "weather" || oldReason == "other" || oldReason == "timer"))
    ))
    {
        logDebug("isOkToTurnOffBecause", item.name + "update denied because it's a downgrade of current reason: " + oldReason + " to " + reason);
        retval = false;
    }

    retval
]


//used as a flag to the global item update handler
//that an ongoing automatic operation is running, 
//to distinguish from an update caused by a person
//pushing a button/switch or giving Alexa a command
var Number isUpdateAutomatic = 0





///
/// Generic Group-based rules
///

rule "gTrackStateReason item changed so track manual state"
when
    Member of gTrackStateReason received command
then
    var DateTime oldTime = null;
    var String oldReason = null;
    var boolean isRecentChange = null;
    var boolean appearsToBeManual = null;

    //this rule is all about tracking manual state changes
    //whoever is automatically changing state will be doing
    //this housekeeping
    try {
        oldTime = lastStateDate.get(triggeringItem.name);
        oldReason = lastStateReason.get(triggeringItem.name);
        isRecentChange  = now.minusSeconds(2).isBefore(oldTime);
    }
    catch(Throwable t) {
        logError("gTrackStateReason", "caught error trying to figure out recency" + t.getMessage())
        if (oldTime === null) { oldTime = now.minusMinutes(99); }
        if (oldReason === null) { oldReason = ""; }
        isRecentChange = true
    }

    appearsToBeManual = isUpdateAutomatic != 1 && ! isRecentChange;

    if (appearsToBeManual && REASON_HEALTH_SAFETY == oldReason){
        //request denied
        logError("gTrackStateReason", "UNABLE TO COMPLY - HEALTH & SAFETY-SET ITEMS CANNOT BE OVERRIDEN MANUALLY");
        isUpdateAutomatic = 1;

        triggeringItem.sendCommand(if(receivedCommand == OFF) {ON} else {OFF});

        Thread.sleep(300);

        isUpdateAutomatic = 0;
    }
    else if (appearsToBeManual) {
        logDebug("gTrackStateReason", "setting item " + triggeringItem.name + " to REASON_MANUAL");
        lastStateReason.put(triggeringItem.name, REASON_MANUAL);
        lastStateDate.put(triggeringItem.name, now);
    }

    var String reasonList 
    
    try {
        reasonList = gTrackStateReason.members.sortBy[ name ].map[ i|
            if (i === null) { return ""; }
            var lastState = if (lastStateReason.get(i.name) !== null) { lastStateReason.get(i.name) } else { "UNKNOWN"; }
            return String::format("%40s", i.name) + " => "+ lastState
        ].reduce[ list, i | return if (i !== null) {list + "\n" + i} else if (list !== null) {list} else {""}];
    }
    catch (Throwable t) {
        reasonList = "shit blew up coming up with the list"
        //logError("gTrackStateReason", "Failed to generate reason list: " + t.getMessage());
    }

    vItemReasonList.postUpdate(reasonList)
end


rule "AutoOff_60 items auto off after 60 minutes unless messed with"
when
    Member of gAutoOff_60 received command ON
then
    //val item = gAutoOff.allMembers.findFirst[] as GenericItem
    var item = triggeringItem
    var existingTimer = autoOffTimers.get(triggeringItem.name);

    if (existingTimer !== null && ! existingTimer.hasTerminated) {
        existingTimer.cancel();
    }

    autoOffTimers.put(triggeringItem.name, createTimer(now.plusMinutes(60), [ |
        //automationLock.lock()
        try {
            isUpdateAutomatic = 1

            item.sendCommand(OFF);
            lastStateReason.put(item.name, REASON_TIMER);
            lastStateDate.put(item.name, now);

            Thread.sleep(200); //guess to let things get caught up
        }
        catch (Throwable t) {
            logError("gAutoOff_60", t.getMessage())
        }
        finally {
            isUpdateAutomatic = 0;
            //automationLock.unlock()
        }

    ]))
end

rule "Luminance and Sun control vIsLightOut"
when
    Item FrontPorchMultisensor_SensorLuminance changed or
    Item LocalSun_Position_Elevation changed
then
    var Number luminance
    var Number elevation
    var Number time = (now.getHourOfDay() * 100) + now.getMinuteOfHour()
    
    try {
        luminance = (FrontPorchMultisensor_SensorLuminance.state as Number).intValue
    }
    catch (Throwable t) {
        luminance = null
        logWarn("vIsLightOut", "failed to compute luminance from " + FrontPorchMultisensor_SensorLuminance.state)
    }

    try{
        elevation = (LocalSun_Position_Elevation.state as Number).intValue
    }
    catch(Throwable t){
        elevation = null
        logWarn("vIsLightOut", "failed to compute elevation from " + LocalSun_Position_Elevation.state)
    }

    if ((luminance < 10 || elevation < 1) && vIsLightOut.state == ON) {
        vIsLightOut.postUpdate(OFF)
    }
    else if ((luminance > 20 && elevation > 1) && vIsLightOut.state == OFF && (time >= 730)) {
        vIsLightOut.postUpdate(ON)
    }
end



///
/// Time-triggered Lights rules
///

rule "Morning Lights on weekday & weekend"
when
  Time cron "0 0 6 ? * MON-FRI" or
  Time cron "0 30 7 ? * SAT,SUN" 
then
    //automationLock.lock();
    try{
        isUpdateAutomatic = 1;

        //this is the dailiy reset of the "Scene"
        vLivingroomScene.postUpdate(SCENE_MORNING);
        lastStateReason.put(vLivingroomScene.name, REASON_TIME);
        lastStateDate.put(vLivingroomScene.name, now);


        if (now.getDayOfWeek < 6 && RyanPresent.state == ON) {         
            RyansDeskLamp_Dimmer.sendCommand(40);
            lastStateReason.put(RyansDeskLamp_Dimmer.name, REASON_TIME);
            lastStateDate.put(RyansDeskLamp_Dimmer.name, now);
        
        
            RyansOtherDeskLamp_Dimmer.sendCommand(100);
            lastStateReason.put(RyansOtherDeskLamp_Dimmer.name, REASON_TIME);
            lastStateDate.put(RyansOtherDeskLamp_Dimmer.name, now);   

            RgbwBulb8_ColorTemperature.sendCommand(50)
            RgbwBulb8_Color.sendCommand(100);
            lastStateReason.put(RgbwBulb8_Color.name, REASON_TIME);
            lastStateDate.put(RgbwBulb8_Color.name, now);   
        }

        CoffeeLight_Switch.sendCommand(ON);
        lastStateReason.put(CoffeeLight_Switch.name, REASON_TIME);
        lastStateDate.put(CoffeeLight_Switch.name, now);

               
        Thread.sleep(200); //let everything catch up before turning off automatic updates
    }
    catch (Throwable t) {
        logError("morning_lights", t.getMessage())
    }
    finally {
        isUpdateAutomatic = 0;
        //automationLock.unlock()
    }
end



rule "Drinking Time"
when
  Time cron "0 0 12 ? * * "  or
  Time cron "0 0 13 ? * * "
then
    //automationLock.lock()
    try {
        isUpdateAutomatic = 1;

        if (isOKToTurnOffBecause.apply(CoffeeLight_Switch, REASON_TIME, lastStateReason, lastStateDate)){
            CoffeeLight_Switch.sendCommand(OFF);
            lastStateReason.put(CoffeeLight_Switch.name, REASON_TIME);
            lastStateDate.put(CoffeeLight_Switch.name, now);
        }

        if (isOKToTurnOnBecause.apply(BarLights_Dimmer, REASON_TIME, lastStateReason, lastStateDate)){
            BarLights_Dimmer.sendCommand(100);
            lastStateReason.put(BarLights_Dimmer.name, REASON_TIME);
            lastStateDate.put(BarLights_Dimmer.name, now);
        }

        Thread.sleep(200); //let everything catch up before turning off automatic updates
    }
    catch (Throwable t) {
        logError("DrinkingTime", t.getMessage())
    }
    finally {
        isUpdateAutomatic = 0;
        //automationLock.unlock()
    }
end

rule "Livingroom Mood Manager"
when
    System started or
    Time cron "0 */10 * ? * *"
then
    var String currentMood = vLivingroomMood.state;
    var Number hour = now.getHourOfDay();
    var boolean isWorkNight = now.getDayOfWeek != 5 && now.getDayOfWeek != 6;
    var String newMood = null;


    if (now.getMonthOfYear == 12 && now.getDayOfMonth==25) {
        newMood = MOOD_FESTIVE_XMAS;
    }
    else if (now.getMonthOfYear == 3 && now.getDayOfMonth==17) {
        newMood = MOOD_FESTIVE_STP;
    }
    else if (now.getMonthOfYear == 7 && now.getDayOfMonth==4) {
        newMood = MOOD_FESTIVE_JULY4;
    }
    else if (hour == 4) {
        newMood = MOOD_MORNING;
    }    
    else if (12 == hour) {
        newMood = MOOD_AFTERNOON;
    }
    else if (16 == hour) {
        newMood = MOOD_EARLY_EVENING;
    }
    else if (18 == hour) {
        newMood = MOOD_MID_EVENING;
    }
    else if ((20 == hour && isWorkNight) || (21 == hour && ! isWorkNight)) {
        newMood = MOOD_LATE_EVENING;
    }
    else if ((21 == hour && isWorkNight) || (23 == hour)) {
        newMood = MOOD_BEDTIME;
    } 


    if (newMood !== null) {
        try{
            isUpdateAutomatic = 1;

            if (isOKToTurnOnBecause.apply(vLivingroomMood, REASON_TIME, lastStateReason, lastStateDate)){
                logDebug("mood_manager", "new mood applied " + newMood);
                vLivingroomMood.postUpdate(newMood);
                lastStateReason.put(vLivingroomMood.name, REASON_TIME);
                lastStateDate.put(vLivingroomMood.name, now);
            }
            else {
                logError("mood_manager", "mood change BLOCKED! would have done " + newMood + "but "+currentMood + " was set manually");
            }

            Thread.sleep(200); //let everything catch up before turning off automatic updates
        }
        catch (Throwable t) {
            logError("mood_manager", t.getMessage())
        }
        finally {
            isUpdateAutomatic = 0;
        }
    }
end

rule "Livingroom auto scene transitions"
when 
    Time cron "0 0 17 ? * * " or
    Time cron "0 0 21 ? * * " or
    Item LivingRoomMultisensor_SensorLuminance changed
then    
    var Number hour = null;
    var Number luminance = null;

    try {
        hour = now.getHourOfDay();
        if (null !== LivingRoomMultisensor_SensorLuminance.state){
            luminance = LivingRoomMultisensor_SensorLuminance.state as Number;
        }
        else {
            luminance = 50;
        }
    }
    catch(Throwable ex) {
        if (null === luminace) {luminance = 50;}
    }

    if ((hour >= 17 && hour <= 18) || (luminance < 40 && hour > 11 && hour < 21)) {
        if (isOKToTurnOnBecause.apply(vLivingroomScene, REASON_TIME, lastStateReason, lastStateDate)){
            vLivingroomScene.postUpdate(SCENE_NORMAL);
            lastStateReason.put(vLivingroomScene.name, REASON_TIME);
            lastStateDate.put(vLivingroomScene.name, now);
        }
    }
    else if (hour >= 21 && vLivingroomScene.state !== SCENE_DARK) {
        if (isOKToTurnOnBecause.apply(vLivingroomScene, REASON_TIME, lastStateReason, lastStateDate)){
            vLivingroomScene.postUpdate(SCENE_COZY);
            lastStateReason.put(vLivingroomScene.name, REASON_TIME);
            lastStateDate.put(vLivingroomScene.name, now);
        }
    }
end

rule "Livingroom set Scene"
when
  System started or
  Item vLivingroomScene changed or
  Time cron "0 */15 * ? * * "
then
  var sofa_level  = 100;
  var floor1_level = 100;  
  var floor2_level = 100;  
  var mantle_level = ON;
  var couch1_level = 100;
  var couch2_level = 100;
  var couch3_level = 100;
  var curio_level = 100;

  var reason;

  if (null !== lastStateReason.get(vLivingroomScene.name)) {
      reason = lastStateReason.get(vLivingroomScene.name);
      logDebug("scenes", "found vLivingroomScene reason " + reason + ", stealing it");
  }
  else {
      reason = REASON_TIME;
      lastStateReason.put(vLivingroomScene.name, reason);
      lastStateDate.put(vLivingroomScene.name, now);
      logError("scenes", "failed to find vLivingroomScene reason, going with time 'cause why not");
  }

  var changeIsBySceneChange = true;


    switch vLivingroomScene.state {
        case SCENE_NORMAL: {
            sofa_level  = 100;
            floor1_level = 100;
            floor2_level = 100;
            mantle_level = ON;
            curio_level = 100;
        }
        case SCENE_MORNING: {
            sofa_level  = 30;
            floor1_level = 30;
            floor2_level = 30
            mantle_level = OFF;
            couch1_level = 35;
            couch2_level = 35;
            couch3_level = 35;
            curio_level = 35;
        } 
        case SCENE_TV: {
            sofa_level  = 18;
            floor1_level = 5;
            floor2_level = 0;
            mantle_level = OFF;
            couch1_level = 5;
            couch2_level = 5;
            couch3_level = 5;
            curio_level = 15;
        }
        case SCENE_MOVIE: {
            floor1_level = 5;
            floor2_level = 5;
            mantle_level = OFF;
            couch1_level = 0;
            couch2_level = 0;
            couch3_level = 0;
            curio_level = 0;
        }
        case SCENE_COZY: {
            sofa_level  = 20;
            floor1_level = 35;
            floor2_level = 35;
            mantle_level = OFF;
            couch1_level = 35;
            couch2_level = 35;
            couch3_level = 35;
            curio_level = 5;
        }
        case SCENE_DARK: {
            sofa_level  = 0;
            floor1_level = 0;
            floor2_level = 0;
            mantle_level = OFF;
            couch1_level = 0;
            couch2_level = 0;
            couch3_level = 0;
            curio_level = 0;
        }  
    }

    logDebug("scenes", "setting scene " + vLivingroomScene.state);
    //automationLock.lock()
    try{
        isUpdateAutomatic = 1;

        if (isOKToTurnOnBecause.apply(RgbwBulb6_Color, reason, lastStateReason, lastStateDate) || changeIsBySceneChange){
            RgbwBulb6_Color.sendCommand(sofa_level);
            lastStateReason.put(RgbwBulb6_Color.name, reason);
            lastStateDate.put(RgbwBulb6_Color.name, now);
        }

        if (isOKToTurnOnBecause.apply(RgbwBulb7_Color, reason, lastStateReason, lastStateDate) || changeIsBySceneChange){
            RgbwBulb7_Color.sendCommand(sofa_level);
            lastStateReason.put(RgbwBulb7_Color.name, reason);
            lastStateDate.put(RgbwBulb7_Color.name, now);
        }


        if (isOKToTurnOnBecause.apply(RgbwBulb5_Color, reason, lastStateReason, lastStateDate) || changeIsBySceneChange){
            RgbwBulb5_Color.sendCommand(floor1_level);
            lastStateReason.put(RgbwBulb5_Color.name, reason);
            lastStateDate.put(RgbwBulb5_Color.name, now);
        }

        if (isOKToTurnOnBecause.apply(RgbwBulb1_Color, reason, lastStateReason, lastStateDate) || changeIsBySceneChange){
            RgbwBulb1_Color.sendCommand(floor2_level);
            lastStateReason.put(RgbwBulb1_Color.name, reason);
            lastStateDate.put(RgbwBulb1_Color.name, now);
        }

        if (isOKToTurnOnBecause.apply(MantleLight_Switch, reason, lastStateReason, lastStateDate) || changeIsBySceneChange){
            MantleLight_Switch.sendCommand(mantle_level);
            lastStateReason.put(MantleLight_Switch.name, reason);
            lastStateDate.put(MantleLight_Switch.name, now);
        }

        if (isOKToTurnOnBecause.apply(RgbwBulb2_Color, reason, lastStateReason, lastStateDate) || changeIsBySceneChange){
            
            RgbwBulb2_Color.sendCommand(couch1_level);
            lastStateReason.put(RgbwBulb2_Color.name, reason);
            lastStateDate.put(RgbwBulb2_Color.name, now);
        }

        if (isOKToTurnOnBecause.apply(RgbwBulb3_Color, reason, lastStateReason, lastStateDate) || changeIsBySceneChange){
            RgbwBulb3_Color.sendCommand(couch2_level);
            lastStateReason.put(RgbwBulb3_Color.name, reason);
            lastStateDate.put(RgbwBulb3_Color.name, now);
        }

        if (isOKToTurnOnBecause.apply(RgbwBulb4_Color, reason, lastStateReason, lastStateDate) || changeIsBySceneChange){
            RgbwBulb4_Color.sendCommand(couch3_level);
            lastStateReason.put(RgbwBulb4_Color.name, reason);
            lastStateDate.put(RgbwBulb4_Color.name, now);
        }

        if (isOKToTurnOnBecause.apply(CurioCabinet_Dimmer, reason, lastStateReason, lastStateDate) || changeIsBySceneChange){
            CurioCabinet_Dimmer.sendCommand(curio_level);
            lastStateReason.put(CurioCabinet_Dimmer.name, reason);
            lastStateDate.put(CurioCabinet_Dimmer.name, now);
        }


        if (vLivingroomScene.state == SCENE_MOVIE || vLivingroomScene.state == SCENE_TV) {
            logDebug("scenes", "new scene is MOVIE or TV");
            //normally these items aren't controlled by the livingroom, but they're
            //in view and can be annoying while watching TV
            //since they don't participate in the scene, we'll set their status to manual
            //so they don't come back up on their own for a while.
            logDebug("scenes", "Movie time is triggering, checking diningroom light state: "  + (DiningroomLights_Dimmer.state as Number).toString);

            if (DiningroomLights_Dimmer.state as Number > 20) {
                logDebug("scenes", "Diningroom Lights were over 20")
                DiningroomLights_Dimmer.sendCommand(15);
                lastStateReason.put(DiningroomLights_Dimmer.name, REASON_MANUAL);
                lastStateDate.put(DiningroomLights_Dimmer.name, now);
            }

            if (BarLights_Dimmer.state as Number > 10) {
                BarLights_Dimmer.sendCommand(25);
                lastStateReason.put(BarLights_Dimmer.name, REASON_MANUAL);
                lastStateDate.put(BarLights_Dimmer.name, now);
            }
        } 

        Thread.sleep(200); //let everything catch up before turning off automatic updates
    }
    catch (Throwable t) {
        logError("scenes", "failed to complete setting up scene: " + t.getMessage())
    }
    finally {
        isUpdateAutomatic = 0;
        //automationLock.unlock();
    }
  
end


rule "Livingroom Set Mood"
when
    System started or
    Item vLivingroomMood changed or
    Time cron "0 */15 * ? * * "
then
    if (null === vLivingroomMood.state) {
        logError("mood_applier", "vLivingroomMood.state was null");
        return;
    }

    var reason;

    if (null !== lastStateReason.get(vLivingroomMood.name)) {
        reason = lastStateReason.get(vLivingroomMood.name);
        logDebug("scenes", "found vLivingroomScene reason " + reason + ", stealing it");
    }
    else {
        reason = REASON_TIME;
        logError("scenes", "failed to find vLivingroomScene reason, going with time 'cause why not");
    }

    logDebug("mood_applier", "mood changed " + vLivingroomMood.state);
    //could do this in an array, but it will eventually be a random list
    //of bulb ids; we're not doing them all just hte ones that are in the living room
    //100 = candellight, 0 = 6000k/daylight
    var bulb1_check  = RgbwBulb1_Color;
    var bulb1_device = RgbwBulb1_ColorTemperature;
    var bulb1_value  = 65;

    var bulb2_check  = RgbwBulb2_Color;
    var bulb2_device = RgbwBulb2_ColorTemperature;
    var bulb2_value  = 65;

    var bulb3_check  = RgbwBulb3_Color;
    var bulb3_device = RgbwBulb3_ColorTemperature;
    var bulb3_value  = 65;

    var bulb4_check  = RgbwBulb4_Color;
    var bulb4_device = RgbwBulb4_ColorTemperature;
    var bulb4_value  = 65;

    var bulb5_check  = RgbwBulb5_Color;
    var bulb5_device = RgbwBulb5_ColorTemperature;
    var bulb5_value  = 65;

    var bulb6_check  = RgbwBulb6_Color;
    var bulb6_device = RgbwBulb6_ColorTemperature;
    var bulb6_value  = 65;

    var bulb7_check  = RgbwBulb7_Color;
    var bulb7_device = RgbwBulb7_ColorTemperature;
    var bulb7_value  = 65;

    try {

        switch vLivingroomMood.state {
            case MOOD_MORNING: {
                bulb1_value = 50;
                bulb2_value = 50;
                bulb3_value = 50;
                bulb4_value = 50;
                bulb5_value = 50;
                bulb6_value = 50;
                bulb7_value = 50;
            }
            case MOOD_AFTERNOON: {
                bulb1_value = 20;
                bulb2_value = 20;
                bulb3_value = 20;
                bulb4_value = 20;
                bulb5_value = 20;
                bulb6_value = 20;
                bulb7_value = 20;
            }
            case MOOD_EARLY_EVENING: {
                bulb1_value = 60;
                bulb2_value = 60;
                bulb3_value = 60;
                bulb4_value = 60;
                bulb5_value = 60;
                bulb6_value = 60;
                bulb7_value = 60;
            }
            case MOOD_MID_EVENING: {
                bulb1_value = 70;
                bulb2_value = 70;
                bulb3_value = 70;
                bulb4_value = 70;
                bulb5_value = 70;
                bulb6_value = 70;
                bulb7_value = 70;
            }
            case MOOD_LATE_EVENING: {
                bulb1_value = 85;
                bulb2_value = 85;
                bulb3_value = 85;
                bulb4_value = 85;
                bulb5_value = 85;
                bulb6_value = 85;
                bulb7_value = 85;
            }
            case MOOD_BEDTIME: {
                bulb1_value = 90;
                bulb2_value = 90;
                bulb3_value = 90;
                bulb4_value = 90;
                bulb5_value = 90;
                bulb6_value = 90;
                bulb7_value = 90;
            }
            case MOOD_COZY: {
                bulb1_value = 100;
                bulb2_value = 100;
                bulb3_value = 100;
                bulb4_value = 100;
                bulb5_value = 100;
                bulb6_value = 100;
                bulb7_value = 100;
            }
            case MOOD_CHIPPER: {
                bulb1_value = 0;
                bulb2_value = 0;
                bulb3_value = 0;
                bulb4_value = 0;
                bulb5_value = 0;
                bulb6_value = 0;
                bulb7_value = 0;
            }
            case MOOD_FESTIVE_XMAS: {
                bulb1_device = RgbwBulb1_Color
                bulb1_value = new HSBType(new DecimalType(0), new PercentType(100), if (NULL ==  RgbwBulb1_Color.state) {100} else {(RgbwBulb1_Color.state as HSBType).brightness});

                bulb2_device = RgbwBulb2_Color
                bulb2_value = new HSBType(new DecimalType(120), new PercentType(90), if (NULL ==  RgbwBulb2_Color.state) {100} else {(RgbwBulb2_Color.state as HSBType).brightness});

                bulb3_device = RgbwBulb3_Color
                bulb3_value = new HSBType(new DecimalType(0), new PercentType(100), if (NULL ==  RgbwBulb3_Color.state) {100} else {(RgbwBulb3_Color.state as HSBType).brightness});

                bulb4_device = RgbwBulb4_Color
                bulb4_value = new HSBType(new DecimalType(0), new PercentType(100), if (NULL ==  RgbwBulb4_Color.state) {100} else {(RgbwBulb4_Color.state as HSBType).brightness});

                bulb5_device = RgbwBulb5_Color
                bulb5_value = new HSBType(new DecimalType(120), new PercentType(90), if (NULL ==  RgbwBulb5_Color.state) {100} else {(RgbwBulb5_Color.state as HSBType).brightness});

                bulb6_device = RgbwBulb6_Color
                bulb6_value = new HSBType(new DecimalType(120), new PercentType(90), if (NULL ==  RgbwBulb6_Color.state) {100} else {(RgbwBulb6_Color.state as HSBType).brightness});

                bulb7_device = RgbwBulb7_Color
                bulb7_value = new HSBType(new DecimalType(0), new PercentType(100), if (NULL ==  RgbwBulb7_Color.state) {100} else {(RgbwBulb7_Color.state as HSBType).brightness});
            }
            case MOOD_FESTIVE_STP: {
                bulb1_device = RgbwBulb1_Color
                bulb1_value = new HSBType(new DecimalType(120), new PercentType(90), if (NULL ==  RgbwBulb1_Color.state) {100} else {(RgbwBulb1_Color.state as HSBType).brightness});

                bulb2_device = RgbwBulb2_Color
                bulb2_value = new HSBType(new DecimalType(120), new PercentType(90), if (NULL ==  RgbwBulb2_Color.state) {100} else {(RgbwBulb2_Color.state as HSBType).brightness});

                bulb3_device = RgbwBulb3_Color
                bulb3_value = new HSBType(new DecimalType(120), new PercentType(90), if (NULL ==  RgbwBulb3_Color.state) {100} else {(RgbwBulb3_Color.state as HSBType).brightness});

                bulb4_device = RgbwBulb4_Color
                bulb4_value = new HSBType(new DecimalType(120), new PercentType(90), if (NULL ==  RgbwBulb4_Color.state) {100} else {(RgbwBulb4_Color.state as HSBType).brightness});

                bulb5_device = RgbwBulb5_Color
                bulb5_value = new HSBType(new DecimalType(120), new PercentType(90), if (NULL ==  RgbwBulb5_Color.state) {100} else {(RgbwBulb5_Color.state as HSBType).brightness});

                bulb6_device = RgbwBulb6_Color
                bulb6_value = new HSBType(new DecimalType(120), new PercentType(90), if (NULL ==  RgbwBulb6_Color.state) {100} else {(RgbwBulb6_Color.state as HSBType).brightness});

                bulb7_device = RgbwBulb7_Color
                bulb7_value = new HSBType(new DecimalType(120), new PercentType(90), if (NULL ==  RgbwBulb7_Color.state) {100} else {(RgbwBulb7_Color.state as HSBType).brightness});
            }
            case MOOD_FESTIVE_JULY4: {
                bulb1_device = RgbwBulb1_Color
                bulb1_value = new HSBType(new DecimalType(0), new PercentType(100), new PercentType(100));

                bulb2_device = RgbwBulb2_Color
                bulb2_value = new HSBType(new DecimalType(0), new PercentType(0), new PercentType(100));

                bulb3_device = RgbwBulb3_Color
                bulb3_value = new HSBType(new DecimalType(0), new PercentType(100), new PercentType(100));

                bulb4_device = RgbwBulb4_Color
                bulb4_value = new HSBType(new DecimalType(240), new PercentType(100), new PercentType(100));

                bulb5_device = RgbwBulb5_Color
                bulb5_value = new HSBType(new DecimalType(0), new PercentType(100), new PercentType(100));

                bulb6_device = RgbwBulb6_Color
                bulb6_value = new HSBType(new DecimalType(240), new PercentType(0), new PercentType(100));

                bulb7_device = RgbwBulb7_Color
                bulb7_value = new HSBType(new DecimalType(240), new PercentType(100), new PercentType(100));
            }
            case MOOD_FESTIVE_EASTER: {
                bulb1_device = RgbwBulb1_Color
                bulb1_value = new HSBType(new DecimalType(0), new PercentType(90), if (NULL ==  RgbwBulb1_Color.state) {100} else {(RgbwBulb1_Color.state as HSBType).brightness});

                bulb2_device = RgbwBulb2_Color
                bulb2_value = new HSBType(new DecimalType(51.42), new PercentType(90), if (NULL ==  RgbwBulb2_Color.state) {100} else {(RgbwBulb2_Color.state as HSBType).brightness});

                bulb3_device = RgbwBulb3_Color
                bulb3_value = new HSBType(new DecimalType(102.84), new PercentType(90), if (NULL ==  RgbwBulb3_Color.state) {100} else {(RgbwBulb3_Color.state as HSBType).brightness});

                bulb4_device = RgbwBulb4_Color
                bulb4_value = new HSBType(new DecimalType(154.26), new PercentType(90), if (NULL ==  RgbwBulb4_Color.state) {100} else {(RgbwBulb4_Color.state as HSBType).brightness});

                bulb5_device = RgbwBulb5_Color
                bulb5_value = new HSBType(new DecimalType(205.68), new PercentType(90), if (NULL ==  RgbwBulb5_Color.state) {100} else {(RgbwBulb5_Color.state as HSBType).brightness});

                bulb6_device = RgbwBulb6_Color
                bulb6_value = new HSBType(new DecimalType(257.1), new PercentType(90), if (NULL ==  RgbwBulb6_Color.state) {100} else {(RgbwBulb6_Color.state as HSBType).brightness});

                bulb7_device = RgbwBulb7_Color
                bulb7_value = new HSBType(new DecimalType(308.52), new PercentType(90), if (NULL ==  RgbwBulb7_Color.state) {100} else {(RgbwBulb7_Color.state as HSBType).brightness});
            }
        }
    }
    catch (Throwable t) {
        logError("mood_applier", "failed to compute mood values: " + t.getMessage())
    }

    try {
        //automationLock.lock();
        isUpdateAutomatic = 1;

        if (isOKToTurnOnBecause.apply(bulb1_check, reason, lastStateReason, lastStateDate)) {
            bulb1_device.sendCommand(bulb1_value);
            lastStateReason.put(bulb1_check.name, reason);
            lastStateDate.put(bulb1_check.name, now);
        }
        if (isOKToTurnOnBecause.apply(bulb2_check, reason, lastStateReason, lastStateDate)) {
            bulb2_device.sendCommand(bulb2_value);
            lastStateReason.put(bulb2_check.name, reason);
            lastStateDate.put(bulb2_check.name, now);
        }
        if (isOKToTurnOnBecause.apply(bulb3_check, reason, lastStateReason, lastStateDate)) {
            bulb3_device.sendCommand(bulb3_value);
            lastStateReason.put(bulb3_check.name, reason);
            lastStateDate.put(bulb3_check.name, now);
        }
        if (isOKToTurnOnBecause.apply(bulb4_check, reason, lastStateReason, lastStateDate)) {
            bulb4_device.sendCommand(bulb4_value);
            lastStateReason.put(bulb4_check.name, reason);
            lastStateDate.put(bulb4_check.name, now);
        }
        if (isOKToTurnOnBecause.apply(bulb5_check, reason, lastStateReason, lastStateDate)) {
            bulb5_device.sendCommand(bulb5_value);
            lastStateReason.put(bulb5_check.name, reason);
            lastStateDate.put(bulb5_check.name, now);
        }
        if (isOKToTurnOnBecause.apply(bulb6_check, reason, lastStateReason, lastStateDate)) {
            bulb6_device.sendCommand(bulb6_value);
            lastStateReason.put(bulb6_check.name, reason);
            lastStateDate.put(bulb6_check.name, now);
        }
        if (isOKToTurnOnBecause.apply(bulb7_check, reason, lastStateReason, lastStateDate)) {
            bulb7_device.sendCommand(bulb7_value);
            lastStateReason.put(bulb7_check.name, reason);
            lastStateDate.put(bulb7_check.name, now);
        }

        Thread.sleep(300);
    }
    catch (Throwable t) {
        logError("mood_applier", "failed to complete setting up mood: " + t.getMessage())
    }
    finally {
        //automationLock.unlock();
        isUpdateAutomatic = 0;
    }

end






rule "Kitchen Evening Lights On"
when
    Time cron "0 0 17 ? * *" or
    Item KitchenMultisensor_SensorLuminance received update
then
    //the lights should come up to 'evening' level if the luminace gets below 30, or 
    //at 5pm, whichever comes first

    var Number hour = now.getHourOfDay()
    var Number luminance = KitchenMultisensor_SensorLuminance.state as Number;

    if (((hour >= 14 && hour < 21) && luminance < 45) || hour == 17) {
        //automationLock.lock()
        try{
            isUpdateAutomatic = 1;
            if (isOKToTurnOnBecause.apply(KitchenCornerLight_Dimmer, REASON_TIME, lastStateReason, lastStateDate)) {
                KitchenCornerLight_Dimmer.sendCommand(100);
                lastStateReason.put(KitchenCornerLight_Dimmer.name, REASON_TIME);
                lastStateDate.put(KitchenCornerLight_Dimmer.name, now);
            }

            if (isOKToTurnOnBecause.apply(KitchenSinkLights_Switch, REASON_TIME, lastStateReason, lastStateDate)) {
                KitchenSinkLights_Switch.sendCommand(ON);
                lastStateReason.put(KitchenSinkLights_Switch.name, REASON_TIME);
                lastStateDate.put(KitchenSinkLights_Switch.name, now);
            }

            if (isOKToTurnOnBecause.apply(CounterLight_Dimmer, REASON_TIME, lastStateReason, lastStateDate)) {
                CounterLight_Dimmer.sendCommand(100);
                lastStateReason.put(CounterLight_Dimmer.name, REASON_TIME);
                lastStateDate.put(CounterLight_Dimmer.name, now);
            }

            if (isOKToTurnOnBecause.apply(CoffeeLight_Switch, REASON_TIME, lastStateReason, lastStateDate)){
                CoffeeLight_Switch.sendCommand(ON);
                lastStateReason.put(CoffeeLight_Switch.name, REASON_TIME);
                lastStateDate.put(CoffeeLight_Switch.name, now);
            }

            if (isOKToTurnOnBecause.apply(DiningroomLights_Dimmer, REASON_TIME, lastStateReason, lastStateDate)){
                DiningroomLights_Dimmer.sendCommand(50);
                lastStateReason.put(DiningroomLights_Dimmer.name, REASON_TIME);
                lastStateDate.put(DiningroomLights_Dimmer.name, now);
            }

            if (isOKToTurnOnBecause.apply(ChinaCabinet_Dimmer, REASON_TIME, lastStateReason, lastStateDate)){
                ChinaCabinet_Dimmer.sendCommand(100);
                lastStateReason.put(ChinaCabinet_Dimmer.name, REASON_TIME);
                lastStateDate.put(ChinaCabinet_Dimmer.name, now);
            }


            Thread.sleep(200); //let everything catch up before turning off automatic updates
        }
        catch (Throwable t) {
            logError("kitchen_evening", t.getMessage())
        }
        finally {
            isUpdateAutomatic = 0;
            //automationLock.unlock()
        }
    }
end




rule "Master Bedroom Luminance Manager"
when
    System started or
    Time cron "0 */15 * ? * *"
then
    var Number time = now.getHourOfDay() * 100 + now.getMinuteOfHour();
    var boolean isWeekend = now.getDayOfWeek() == 6 || now.getDayOfWeek == 7;
    var boolean isWorkNight = now.getDayOfWeek != 5 && now.getDayOfWeek != 6;

    var target = 0;

    if (time > 800 && ((time < 1230 && isWeekend) || (time < 1100))) {
        target = 40;
    }
    else if (time > 1100 && time < 1800) {
        target = 10;
    }
    else if (time > 1800 && time < 2045 && isWorkNight) {
        target = 60;
    }
    else if (time > 1800 && time < 2300 && ! isWorkNight) {
        target = 60;
    }

    logDebug("bedroom_manager", "Master bedroom luminance target is now " + target.toString());

    isUpdateAutomatic = 1;
    if (isOKToTurnOnBecause.apply(vMasterBedroomLuminanceTarget, REASON_TIME, lastStateReason, lastStateDate)) {
        vMasterBedroomLuminanceTarget.postUpdate(target);
        lastStateReason.put(vMasterBedroomLuminanceTarget.name, REASON_TIME);
        lastStateDate.put(vMasterBedroomLuminanceTarget.name, now);
    }

    Thread.sleep(200);
    isUpdateAutomatic = 0;

end


rule "Master Bedroom Light Manager"
when
    Item MasterBedroomMultisensor_SensorLuminance received update or
    Item vMasterBedroomLuminanceTarget received update
then
    if (MasterBedroomOverheadLight_Dimmer === null || MasterBedroomOverheadLight_Dimmer.state === null) {
        logWarn("bedroom_applier", "dimmer state is null?");
    }

    if (MasterBedroomMultisensor_SensorLuminance === null || MasterBedroomMultisensor_SensorLuminance.state === null) {
        logWarn("bedroom_applier", "luminance state is null? ABORTING");
        return;
    }

    if (vMasterBedroomLuminanceTarget === null || vMasterBedroomLuminanceTarget.state === null) {
        logWarn("bedroom_applier", "luminance target is null? ABORTING");
        return;
    }


    //TODO: This should come from a whole-house mode flag
    if (2100 < (now.getHourOfDay() * 100 + now.getMinuteOfHour())) {
       logInfo("bedroom_applier", "it's after 9pm, the bedroom light is effectively under manual control");
        return 
    }

    var Number luminance = if (MasterBedroomMultisensor_SensorLuminance.state !== null) { MasterBedroomMultisensor_SensorLuminance.state as Number } else { 50 };
    var Number dimlevel = if (MasterBedroomOverheadLight_Dimmer.state !== null) { MasterBedroomOverheadLight_Dimmer.state as Number } else {50};
    var Number target = vMasterBedroomLuminanceTarget.state;

    var Number newlevel = null;

    logDebug("bedroom_applier", "target: " + target.toString());
    logDebug("bedroom_applier", "current: " + luminance.toString());
    logDebug("bedroom_applier", "dimmer: " + dimlevel.toString());

    if (luminance + 5 < target ) {
        newlevel = dimlevel + ((target - luminance)/2);
        if (newlevel > 100) { newlevel = 100; }
    }
    else if (luminance - 5 > target) {
        newlevel = dimlevel - ((luminance - target) / 2);
        if (newlevel < 0) { newlevel = 0; }
    }

    if(newlevel !== null) {
        try {
            logDebug("bedroom_applier", "Master bedroom dimmer setting will be " + newlevel.toString())
            isUpdateAutomatic = 1;
            if (isOKToTurnOnBecause.apply(MasterBedroomOverheadLight_Dimmer, REASON_WEATHER, lastStateReason, lastStateDate)) {
                MasterBedroomOverheadLight_Dimmer.sendCommand(newlevel);
                lastStateReason.put(MasterBedroomOverheadLight_Dimmer.name, REASON_WEATHER);
                lastStateDate.put(MasterBedroomOverheadLight_Dimmer.name, now);
                logDebug("bedroom_applier", "Master bedroom dimmer setting is now " + newlevel.toString());
            }
            else {
                logWarn("bedroom_applier", "update to dimmer denied");
            }
        }
        catch (Throwable t) {
            logError("bedroom_applier", "error setting bedroom dimmer: " + t.getMessage());
        }
        finally {
            Thread.sleep(200);
            isUpdateAutomatic = 0;
            logDebug("bedroom_applier", "done setting dimmer")
        }
    }
    else {
        logDebug("bedroom_applier", "no bedroom light level change needed");
    }
end


rule "Nighttime"
when
    Time cron "0 30 22 ? * MON,TUE,WED,THU,SUN *" or
    Time cron "0 59 23 ? * FRI,SAT *" or
    Item Scene_NightLights received command ON or
    Item Scene_AllOff received command ON
then
    //automationLock.lock()
    try {
        isUpdateAutomatic = 1;

        gGoodnightLights.members.forEach[ i | 
            if (isOKToTurnOffBecause.apply(i, REASON_GOODNIGHT, lastStateReason, lastStateDate)) {
                i.sendCommand(OFF);
                lastStateReason.put(i.name, REASON_GOODNIGHT);
                lastStateDate.put(i.name, now);
            }
            true
        ]

        
        vLivingroomScene.postUpdate(SCENE_DARK);
        lastStateReason.put(vLivingroomScene.name, REASON_GOODNIGHT);
        lastStateDate.put(vLivingroomScene.name, now); 
        

        Scene_NightLights.sendCommand(OFF);
        Scene_AllOff.sendCommand(OFF);

        Thread.sleep(200);
    }
    catch (Throwable t) {
        logError("nighttime", t.getMessage())
    }
    finally {
        Thread.sleep(300);
        isUpdateAutomatic = 0;
        //automationLock.unlock()
    }
end


///
/// Variously-triggered blinds rules
///

rule "Non-Bedroom blinds open in the morning"
when
    Time cron "0 30 8 ? * MON-FRI" or
    Time cron "0  0 9 ? * SAT,SUN" or
    Item vIsLightOut changed from OFF to ON
then
    var ourreason = REASON_TIME;

    if (triggeringItem !== null && triggeringItem.name == "vIsLightOut") {
        ourreason = REASON_WEATHER;
    }

    //automationLock.lock()
    try {
        isUpdateAutomatic = 1;

        gAllBlinds.members.filter[ b | !b.getGroupNames.contains("gBedroomBlinds") ].forEach [ b | 
            if (isOKToTurnOnBecause.apply(b, ourreason, lastStateReason, lastStateDate)) {
                b.sendCommand(UP)
                lastStateReason.put(b.name, ourreason);
                lastStateDate.put(b.name, now);
            }
            true
        ]

        Thread.sleep(200);
    }
    catch (Throwable t) {
        logError("non-bedroom blinds", t.getMessage())
    }
    finally {
        isUpdateAutomatic = 0;
        //automationLock.unlock()
    }
end


rule "Bedroom blinds open in the morning"
when
    Time cron "0 45 8 ? * MON-FRI" or
    Time cron "0 15 9 ? * SAT,SUN"
then
    logDebug("bedroom blinds", "rule triggered")

    //automationLock.lock()
    try {
        isUpdateAutomatic = 1;

        gBedroomBlinds.members.forEach [ b | 
            if (isOKToTurnOnBecause.apply(b, REASON_TIME, lastStateReason, lastStateDate)) {
                b.sendCommand(UP)
                lastStateReason.put(b.name, REASON_TIME);
                lastStateDate.put(b.name, now);
            }
        ]

        Thread.sleep(200);
    }
    catch (Throwable t) {
        logError("bedroom blinds", t.getMessage())
    }
    finally {
        isUpdateAutomatic = 0;
        //automationLock.unlock()
    }
end


rule "All blinds close when it gets dark out"
when
    Item vIsLightOut changed from ON to OFF or
    Channel "astro:sun:local:set#event" triggered START or
    Time cron "0 45 20 * * ?"
then
    var ourreason = REASON_TIME;
    if (triggeringItem !== null && triggeringItem.name == "vIsLightOut") {
        ourreason = REASON_WEATHER;
    }

    //automationLock.lock()
    try {
        isUpdateAutomatic = 1;

        gAllBlinds.members.forEach [ blind | 
            if (isOKToTurnOnBecause.apply(blind, ourreason, lastStateReason, lastStateDate)) {
                blind.sendCommand(DOWN)
                lastStateReason.put(blind.name, ourreason);
                lastStateDate.put(blind.name, now);
            }
            true
        ]

        Thread.sleep(200);
    }
    catch (Throwable t) {
        logError("blinds close", t.getMessage())
    }
    finally {
        isUpdateAutomatic = 0;
        //automationLock.unlock();
    }
end

///
/// Weather based rules
///

rule "Auto Deck Lights"
when
  Item LocalSun_Position_Elevation changed
then
  var int cloudiness =(LocalWeatherAndForecast_Current_Cloudiness.state as Number).intValue
  var int temperature = (LocalWeatherAndForecast_Current_OutdoorTemperature.state as Number).intValue
  var int elevation = (LocalSun_Position_Elevation.state as Number).intValue

  //the cloudier it is, the earlier the lights should turn on
  var int topElevation = 15 + ( 20 * (cloudiness / 100))

  //68 is a rough guess of when we'd likely be outside
  if (elevation < topElevation && elevation > 0 && temperature > 68) {
      //automationLock.lock()
      try{
        isUpdateAutomatic = 1;
        if (isOKToTurnOnBecause.apply(DeckLights_Switch, REASON_WEATHER, lastStateReason, lastStateDate)){
            DeckLights_Switch.sendCommand(ON);
            lastStateReason.put(DeckLights_Switch.name, REASON_WEATHER);
            lastStateDate.put(DeckLights_Switch.name, now);
        }

        if (isOKToTurnOnBecause.apply(PorchLights_Switch, REASON_WEATHER, lastStateReason, lastStateDate)){
            PorchLights_Switch.sendCommand(ON);
            lastStateReason.put(PorchLights_Switch.name, REASON_WEATHER);
            lastStateDate.put(PorchLights_Switch.name, now);
        }

        Thread.sleep(200);  
      }
      catch (Throwable t) {
        logError("deck lights", t.getMessage())
      }
      finally {
        isUpdateAutomatic = 0;
        //automationLock.unlock()
      }
  }
end


///
/// Motion Rules
///

rule "Nightlight Triggered"
when
    Member of gNightlight_Livingroom_Sensor changed or
    Member of gNightlight_Bathroom_Sesnsor changed or
    Member of gNightlight_Kitchen_Sensor changed or
    Member of gNightlight_ROffice_Sensor changed
then
    var String nightlightGroup = triggeringItem.getGroupNames.findFirst[ g | g.startsWith("gNightlight")];
    var GroupItem luminanceGroup = ScriptServiceUtil.getItemRegistry.getItem(nightlightGroup.replace('Sensor', 'Luminance'));
    var GroupItem lightsGroup    = ScriptServiceUtil.getItemRegistry.getItem(nightlightGroup.replace('Sensor', 'Light'));
    
    var Number luminanceResult = 100;

    try {
        luminanceResult = luminanceGroup.members.map[ l|l.state as Number].reduce[sum, l|sum+l ]
    }
    catch (Throwable t) {
        logError("nightlight", "failed to compute luminance via map/reduce, was something null? \n" + t.getMessage)
    }
   

    if (triggeringItem.state === ON && luminanceResult < 10) {
        logDebug("nightlight", triggeringItem.name + " motion triggered with luminance in range");
        //automationLock.lock()
        try {
            isUpdateAutomatic = 1;


            lightsGroup.members.forEach[ i |
                if (isOKToTurnOnBecause.apply(i, REASON_MOTION, lastStateReason, lastStateDate)) {
                    i.sendCommand(ON)
                    lastStateReason.put(i.name, REASON_MOTION)
                    lastStateDate.put(i.name, now)
                    if(autoOffTimers.get(i.name)) {autoOffTimers.get(i.name).cancel();}
                    autoOffTimers.put(i.name, null)
                }
            ]

            Thread.sleep(200)
        }
        catch(Throwable t) {
            logWarn("nightlight on", t.getMessage())
        }
        finally {
            isUpdateAutomatic = 0;
            //automationLock.unlock()
        }
    }
    else if (triggeringItem.state === ON) {
        //we should still kill any running timers
        lightsGroup.members.forEach[ i |
            if(autoOffTimers.get(i.name)) {autoOffTimers.get(i.name).cancel();}
            autoOffTimers.put(i.name, null)
        ]

    }
    else if (triggeringItem.state === OFF) {
        logDebug("nightlight", triggeringItem.name + " motion stopped");
        lightsGroup.members.forEach[ i |
            //if this light isn't on by motion now, there's no point in scheduling the timer
            if (lastStateReason.get(i.name) !== REASON_MOTION) {
                //but still kill any running timer!!!
                if(autoOffTimers.get(i.name)) {autoOffTimers.get(i.name).cancel();}
                autoOffTimers.put(i.name, null)
                return;
            }

            if(autoOffTimers.get(i.name)) {autoOffTimers.get(i.name).cancel();}

            autoOffTimers.put(i.name, createTimer(now.plusMinutes(2), [ |
                //automationLock.lock();
                isUpdateAutomatic = 1;
                try{
                    if (isOKToTurnOffBecause.apply(i, REASON_MOTION, lastStateReason, lastStateDate)) {
                        i.sendCommand(OFF)
                        lastStateReason.put(i.name, REASON_MOTION)
                        lastStateDate.put(i.name, now)
                        if(autoOffTimers.get(i.name)) {autoOffTimers.get(i.name).cancel();}
                        autoOffTimers.put(i.name, null)
                    }
                }
                catch(Throwable t) {
                    logWarn("nightlight off", "Caught Exception:" + t.getMessage())
                }
                finally{
                    Thread.sleep(200);
                    isUpdateAutomatic = 0;
                    //automationLock.unlock();
                }
            ]))
        ]
    }
end

rule "Extreme High Humidity Triggers Fans"
when
    Item MasterBathroom_RelativeHumidity changed
then
    //This rule does it's own current state checking so doesn't use the lambdas
    //that compare state. REASON_HEALTH_SAFETY trumps all, and we wouldn't be
    //able to clear it if we used the normal checks.

    val Number humidity = MasterBathroom_RelativeHumidity.state as Number
    val fanState = MasterBathroomFan_Switch.state
    val fanStateReason = lastStateReason.get(MasterBathroomFan_Switch.name)
    val heaterStateReason = lastStateReason.get(BathroomHeater_Switch.name)

    if (humidity > 80 && (fanState == OFF || fanStateReason != REASON_HEALTH_SAFETY)) {
        logWarn("bathroom high humidity", "Turning on bathroom fan due to extreme humidity");
        isUpdateAutomatic = 1;

        lastStateReason.put(MasterBathroomFan_Switch.name, REASON_HEALTH_SAFETY);
        lastStateDate.put(MasterBathroomFan_Switch.name, now);
        MasterBathroomFan_Switch.sendCommand(ON);

        lastStateReason.put(BathroomHeater_Switch.name, REASON_HEALTH_SAFETY);
        lastStateDate.put(BathroomHeater_Switch.name, now);
        BathroomHeater_Switch.sendCommand(ON);

        Thread.sleep(200);

        isUpdateAutomatic = 0;
    }
    else if (humidity < 60  && (fanStateReason == REASON_HEALTH_SAFETY || heaterStateReason == REASON_HEALTH_SAFETY)) {
        logInfo("bathroom high humidity", "Humidity Cleared, turning off fan");
        isUpdateAutomatic = 1; 

        MasterBathroomFan_Switch.sendCommand(OFF);
        lastStateReason.put(MasterBathroomFan_Switch.name, REASON_WEATHER); //something eles can override this
        lastStateDate.put(MasterBathroomFan_Switch.name, now);

        lastStateReason.put(BathroomHeater_Switch.name, REASON_WEATHER);
        lastStateDate.put(BathroomHeater_Switch.name, now);
        BathroomHeater_Switch.sendCommand(OFF);

        Thread.sleep(200);

        isUpdateAutomatic = 0;
    }
end

rule "High Humidity Triggers Fans"
when
    Item MasterBathroom_RelativeHumidity changed
then
    val Number humidity = MasterBathroom_RelativeHumidity.state as Number
    val fanState = MasterBathroomFan_Switch.state
    
    if (humidity > 60 && fanState == OFF) {
        isUpdateAutomatic = 1;

        logWarn("bathroom high humidity", "Turning on bathroom fan due to high humidity");

        if (isOKToTurnOnBecause.apply(MasterBathroomFan_Switch, REASON_WEATHER, lastStateReason, lastStateDate)){
            logWarn("bathroom high humidity", "Turning on bathroom fan due to high humidity (past state check)");
            MasterBathroomFan_Switch.sendCommand(ON);
            lastStateReason.put(MasterBathroomFan_Switch.name, REASON_WEATHER);
            lastStateDate.put(MasterBathroomFan_Switch.name, now);
        }

        Thread.sleep(200);

        isUpdateAutomatic = 0;
    }
    else if (humidity < 55 && fanState == ON) {
        isUpdateAutomatic = 1; 

        logInfo("bathroom high humidity", "Humidity Cleared, turning off fan");

        if (isOKToTurnOffBecause.apply(MasterBathroomFan_Switch, REASON_WEATHER, lastStateReason, lastStateDate)){
            MasterBathroomFan_Switch.sendCommand(OFF);
            lastStateReason.put(MasterBathroomFan_Switch.name, REASON_WEATHER);
            lastStateDate.put(MasterBathroomFan_Switch.name, now);
        }

        Thread.sleep(200);

        isUpdateAutomatic = 0;
    }
end
